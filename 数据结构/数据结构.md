# 一  线性表

## 1 基本数据类型  和 抽象数据类型 定义

基本数据类型反映了数据的取值范围以及对这类数据可以施加的运算。  

抽象数据类型（abstract data type,ADT）只是⼀个数学模型以及定义在模型上的⼀组操作。通
常是对数据的抽象，定义了数据的取值范围以及对数据操作的集合。 <font color='red'> (进行归一化)</font>

## 2 线性表的抽象数据类型  

线性表抽象数据类型主要包括两个⽅⾯：既<font color='red'>数据集合(对数据的抽象)和该数据集合上的(操作集合)。  </font>

## 3 线性结构  

如果⼀个数据元素序列满⾜：  

1.除第⼀个和最后⼀个数据元素外，每个数据元素<font color='red'>只有⼀个前驱数据元素和⼀个后继数据</font>元素；

2.<font color='red'>第⼀个数据元素没有前驱数据元素</font>；

3.<font color='red'>最后⼀个数据元素没有后继数据元素</font>；

我们称这样的结构就叫做 线性结构  

## 4.顺序表  

在计算机内存中，顺序表是以数组的形式保存的线性表。也就是<font color='red'>⼀组地址连续的存储单元</font>依次
存储数据元素的线性结构。  

在数组中，我们会先申请⼀段连续的内存空间，然后把数组以此存⼊内存当中，中间没有⼀点
空隙。这就是⼀种顺序表存储数据的⽅式。对于顺序表的基本操作有：增（add），删（remove），改（set），查（find），插（insert）。  

```C
#include<stdio.h>
#include<stdlib.h>
/*顺序表 数组*/
typedef struct ArrayList {
	int* list;//数组
	int count;//记录当前元素个数
	int maxSize;//总容量
}List;
List* initList();//数组初始化方法
void insert(int key, List* list);//数组插入方法
int find(List* list, int key);//数组查找方法
void insert_index(int key, List* list, int data);//按照下表进行插入
void printfList(List* list);//打印数组
void delete_list(int key, List* list);//删除数组
void enlargement(List* list);//进行数组扩大
int main()
{
	List* list = initList();
	insert(1, list);
	insert(2, list);
	insert(3, list);
	insert(4, list);
	insert(5, list);
	insert(6, list);
	printfList(list);
}

//初始化
List* initList()
{
	List* list = (List*)malloc(sizeof(List));
	list->count = 0;
	list->maxSize = 5;
	list->list = (int*)malloc(sizeof(int) * 5);
	return list;
}


void enlargement(List* list)
{
	int* temp = (int*)malloc(sizeof(int) * (list->maxSize + 5));//malloc一个当前最大容量+5的数组
	for (int i = 0; i < list->maxSize; i++)//进行数据的迁移
    {
        	temp[i] = list->list[i];
    }

    //将当前头指针指向新增的数组地址
	int* arrytemp = list->list;
	list->list = temp;
	list->maxSize = list->maxSize + 5;//修改当前数组的最大容量
	free(arrytemp);//释放原来申请的地址空间
}


/*
顺着插入
*/
void insert(int key, List* list)//key插入元素值 list数组的指针
{
    //判断当前是否能插入
	if (list->count < list->maxSize)
	{
		list->list[list->count] = key;
		list->count++;
	}
	else
	{
		//提示满了 或者直接扩容
		enlargement(list);
		list->list[list->count] = key;
		list->count++;
	}
}


int find(List* list, int key)//key查找的值 list数组的指针
{
	for (int i = 0; i < list->count; i++)
	{
		if (list->list[i] == key)
		{
			return i;//找到了返回下标
		}
	}
	return -1;//没有找到
}

/*
在某个元素之前插入
1、插入什么元素
2、在哪个顺序表插入
3、在哪个元素之前插入
*/
void insert_index(int key, List* list, int data)//key要插入的值 list数组的指针 data为插入位置元素的值
{
	if (list->count < list->maxSize)
	{
		int index = find(list, data);
		if (index==-1)
		{
			//没有这个元素 提示 退出
			return;
		}
		else
		{
			//先移动位置  从后面往前面移动
			for (int i = list->count; i > index; i--)
			{
				list->list[i] = list->list[i - 1];
			}
			list->list[index] = key;
			list->count++;
		}
	}
	else 
	{
		//提示满了 或者 扩容
	}
}


void printfList(List* list)
{
	for (int i = 0; i < list->count; i++)
	{
		printf("%d ", list->list[i]);
	}
	printf("\n");
}

void delete_list(int key, List* list)
{
	if (list->count == 0)
	{
		return;
	}
	else 
	{
		int index = find(list, key);
		if (index == -1)
		{
			return;
		}
		else
		{
			for (int i = index; i < list->count; i++)
			{
				list->list[i] = list->list[i + 1];
			}
			list->count--;
		}
	}
}
```



### 4.1顺序表删除元素  

从顺序表中删除指定的元素，其实实现起来是⾮常简单的，只需要找到⽬标元素，并将
<font color='red'>其后续的所有元素整体前移1个位置</font>即可。  

![image-20230209192249511](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209192249511.png)

![image-20230209192253639](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209192253639.png)

![image-20230209192302125](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209192302125.png)

顺序表删除元素，其实是在<font color='red'>间接删除⽬标元素</font>。就是将后续元素整体向前移动⼀个位置。  

#### 4.1.1删除元素时间复杂度分析

最好的情况是删除的元素刚好是最后⼀个元素，这时候不需要移动元素，只需要把表的size-1即可。

最坏的时间复杂度刚好是第⼀个元素，这个时候需要后⾯全部的元素向前移动⼀位，同时size - 1，时间复杂度是O(N)。

我们<font color='red'>分析时间复杂度的原则是分析最坏情况</font>，这样才有意义。因此删除操作的时间复杂度为O(N)。  

### 4.2顺序表插⼊元素  

向已有的顺序表中插⼊元素，根据插⼊的位置不同，可以分为3种情况。
1.插⼊到顺序表的表头
2.在表中间位置插⼊
3.尾随顺序表中已有的元素，作为最后⼀个元素插⼊
虽然数据元素插⼊顺序表中的位置有所不同，但是都是使⽤的是同⼀个⽅法去解决的。就是
<font color='red'>通过遍历，找到数据元素要插⼊的位置。</font>然后要做到如下两步⼯作。
<font color='red'>将要插⼊的位置元素以及后续的元素整体向后移动⼀个位置</font>
<font color='red'>将元素放到腾出来的位置上。  </font>

例如，在{1,2,4,5,6,7}的第三个位置插⼊3.实现过程如下  

![image-20230209192550019](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209192550019.png)

![image-20230209192553874](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209192553874.png)

![image-20230209192556803](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209192556803.png)

#### 4.2.1时间复杂度

<font color='red'>同删除元素是⼀样的，均为O(N)。  </font>

### 4.3优势和缺点

#### 优势  :

- 数据在数组中按顺序存储，可以通过数组下标直接访问，因此顺序表的<font color='red'>查找定位元素</font>很
  快  

#### 劣势  :

- 插⼊和删除元素都需要⼤量的操作。
- 因为数组在声明的时候需要确定⻓度，因此<font color='red'>顺序表的⻓度是确定</font>的。若需要扩⼤顺序表⻓
  度，有需要⼤量的操作，不够灵活。（要将该数组中的元素全部copy到另外⼀个数组）
- 由于<font color='red'>数据⼤⼩的不可测性</font>，有时会浪费掉⼤量的空间。  

### 4.4应⽤场景  

顺序表适⽤于那些<font color='red'>不需要对于数据进⾏⼤量改动的结构</font>。  

### 4.5顺序表的效率分析  

顺序表对于插⼊、删除⼀个元素的时间复杂度是O(n)。

因为顺序表⽀持随机访问，顺序表读取⼀个元素的时间复杂度为O(1）。因为我们是通过下标
访问的，所以时间复杂度是固定的，和问题的规模⽆关。

<font color='red'>最⼤的优点是空间利⽤率⾼。最⼤的缺点是⼤⼩固定。  </font>

## 5.链表

在⽆序数组中，搜索时⼗分低效。
在有序数组中，插⼊的效率很低。不管在哪种数组中，删除的效率都很低。⽽且⼤⼩⽆法改变。

为了应对顺序表的缺陷，链表就此诞⽣。链表也是继数组之后第⼆种使⽤的最⼴泛的通⽤数据结构
链表结构：<font color='red'>在物理上不连续，在逻辑上连续</font>。⼤⼩不固定。
链式存储结构是基于指针实现的。我们把⼀个数据元素和⼀个指针称之为节点。  

![image-20230209192938640](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209192938640.png)

数据域：存数据元素的区域
指针域：存储直接后继位置的区域。
链式存储，其实就是⽤指针将相互关联的结点链接起来。
链式存储根据链表的构造不同，可以分成：<font color='red'>单向链表，单向循环链表，双向链表，双向循环链表。  </font>

### 5.1单向链表  

#### 5.1.1概念

链表的每个节点<font color='red'>只包含⼀个指针域</font>。叫做单链表（即构成链表的每个节点只有⼀个指向后继节点的指针）  

#### 5.1.2头指针和头节点  

单链表有带头节点和不带头节点两种结构。  

链表中，第⼀个结点存储的位置叫头指针，如果链表有头结点，那么<font color='red'>头指针就是指向头结点的指针。  </font>

头指针所指的<font color='red'>不存在数据元素的第⼀个结点就叫做头结点</font>（⽽头结点⼜指向⾸元结点）。头结点<font color='red'>⼀般不放数据（有的时候也是放的，⽐如链表的⻓度，⽤做监视）</font>。  

存放第⼀个数据元素的结点叫做第⼀个数据元素结点，也叫做<font color='red'>⾸元结点</font>

![image-20230209193244343](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209193244343.png)

![image-20230209193251458](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209193251458.png)

![image-20230209193259459](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209193259459.png)

![image-20230209193308544](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209193308544.png)

```c
#include <stdio.h>
#include <stdlib.h>
/*带头结点的单向链表*/
/*数据集合  结点*/
typedef struct NodeList {
	int element;//存储具体的数组
	struct NodeList* next;//用来指向下一个结点的指针
    //int count;//重复数据的个数但是实际的重复行为一般不会出现
	//int ID;//索引 将个体进行区分
}Node;
/*操作集合*/

/*
初始化一个节点
*/
Node* InitList(Node* node)
{
	node = (Node*)malloc(sizeof(Node));//malloc一个新节点
	if (node==NULL)
	{
		//分配失败 初始化失败进行提醒
	}
	else
	{
		node->next = NULL;
	}
	return node;
}
```



#### 5.1.3不带头结点的单链表的插⼊操作  

![image-20230209193325567](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209193325567.png)

如果我们在<font color='red'>⾮第⼀个结点之前</font>做插⼊操作，我们只需要<font color='red'>把新结点的指针域指向a（i），然后将a（i - 1）的指针域指向新的结点。</font>如果我们在<font color='red'>第⼀个结点之前进⾏插⼊操作，那么头指针就要等于新插⼊的节点，这和在⾮第⼀个数据元素结点前插⼊时的情况不同。</font>⽽且，还有⼀些不同的情况需要我们做考虑。所以，当我们设计此类链表的时候，就要<font color='red'>分别设计实现⽅法。  </font>

#### 5.1.4带头结点的单链表的插⼊操作  

![image-20230209193425009](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209193425009.png)

如果采⽤带头结点的单链表结构，算法实现的时候，<font color='red'> p指向头结点，改变p的指针的next的值，就可以了，⽽头指针head的值不变。</font>因此，算法的实现⽅法⽐较简单，其操作与对其他结点的操作统⼀。  

带头结点的好处就是，<font color='red'>⽅便对于链表的操作。对于空表、⾮空表的情况以及对于⾸元结点都可以进⾏统⼀的处理。  </font>

```C
/*
向单链表中插入一个数据 头插
1、插入的具体数据是什么
2、往哪个单链表里面插入
*/
void head_insert(Node* node, int key)
{
	Node* temp = (Node*)malloc(sizeof(Node));//创建新节点
	temp->next = node->next;
	node->next = temp;
	temp->element = key;
}
```

#### 5.1.4单链表的查找

```C
int find(Node* node, int key)
{
	Node* temp;
	temp = node->next;
	int i = 0;
	while (temp != NULL)
	{
		if (temp->element == key)
		{
			return i;
		}
		temp = temp->next;
		i++;
	}
	return -1;
}
```



#### 5.1.5单链表的删除

```C
/*
1、在那个链表里删除
2、删除的数据是什么
3.是否要考虑重复数据
*/
void detele(Node* node, int key)
{
	//先查找
	int index = find(node, key);
	if (index == -1)
	{
		//没找到 提示一下
	}
	else {

		Node* temp;
		temp = node;
		int i = 0;
		while ( i < index)
		{
			temp = temp->next;
			i++;
		}
		Node* free_node = temp->next;
		temp->next = temp->next->next;
		free(free_node)
	}
}
```



### 5.2循环链表  

单向循环链表，他是单链表的⼜⼀种表现形式。<font color='red'>最后⼀个结点的指针不再是结束标记。⽽是指向了整个链表的第⼀个结点</font>，从⽽使得单链表形成⼀个环。  

和单链表相⽐，循环链表的⻓处就是，<font color='red'>从链尾到链头⽐较⽅便</font>。当要<font color='red'>处理的数据元素序列具有环形结构</font>特点的时候，适合于采⽤循环链表。

和单链表相同，循环链表也分为带头结点结构和不带头结点结构两种，同样带头结点的循环单链表实现插⼊和删除操作的时候，算法实现⽐较⽅便。  

![image-20230209193636206](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209193636206.png)

![image-20230209193638843](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209193638843.png)

带头结点的循环单链表的操作实现⽅法和带头结点的单链表的操作实现⽅法基本相同，唯⼀
的差别是在
1、在构造函数中，要加⼀条`head.next = head`语句。把初始时的带头结点的循环单链
表设计成图示的状态。
2、在index成员函数中，把<font color='red'>循环条件不等于null改成不等于head。  </font>

### 5.3双向链表  

双向链表，每个结点包含三个域，分别是`element， next， piror`。其中element是数据元素。 next为指向后记结点对象的引⽤， prior域是指向前驱结点对象的引⽤。  

![image-20230209193734089](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209193734089.png)

### 5.4双向循环链表  

![image-20230209193744347](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209193744347.png)

![image-20230209193747591](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209193747591.png)

![image-20230209193750650](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209193750650.png)

```C
#include<stdio.h>
#include<stdlib.h>

typedef struct DoubleList {
	struct DoubleList* front;//前指针
	int element;//
	struct DoubleList* next;//后指针
}List;

List* head;

void InitList()
{
	head = (List*)malloc(sizeof(List));
	head->next = head;
	head->front = head;
}
//头插法插入元素
void head_insert(int key)
{
	List* new_node = (List*)malloc(sizeof(List));
	new_node->element = key;
	new_node->next = head->next;
	new_node->front = head;
	head->next->front = new_node;
	head->next = new_node;
}
//查找值为key的元素
int find(int key)
{
	List* temp = head->next;
	int i = 0;
	while (temp != head)
	{
		if (temp->element == key)
		{
			return i;//找到了返回下标
		}
		i++;
		temp = temp->next;
	}
	return -1;
}


void delete_node(int key)//删除值为key的节点
{
	
	if (head == NULL)
	{
		//不存在链表时
	}
	else
	{
		int index = find(key);
		if (index == -1)
		{
			//没有找到元素
		}
		else
		{
			List* temp = head;
			int i = 0;
			while (i < index)
			{
				temp = temp->next;
				i++;
			}
			List* free_node = temp->next;
			temp->next->next->front = temp;
			temp->next = temp->next->next;
			free(free_node);
		}
	}
}
```

# 二 栈和队列  

## 1 栈

### 1.1物理中的堆栈  

CPU当中，有⼀个⾮常核⼼的模块，叫做ALU（算术逻辑单元），也就是执⾏各种计算和逻辑运算操作的⼀个部件，是我们CPU的执⾏单元。  ⽐如1 + 1 = 2。如果说，有多个运算参与，⽐如111 +222 + 333，这个时候，他会先计算 111 + 222 ，然后得到⼀个临时结果，再将我们的临时结果和剩下的数字相加。这个时候，我们就需要将临时结果找个地⽅存⼀下，这个地⽅，我们叫寄存器他们的名字就是AX， BX， CX， DX等等。临时结果就保存在寄存器中。为了实现更复杂的计算，能不能做特别多的寄存器呀？答案是不能，如果做特别多的寄存器，只会增加我们的CPU设计上的成本和复杂性。这个时候，就需要从外⾯找帮⼿。这个帮⼿需要什么条件呢？那就是速度要快。然后，计算机的设计者就将⽬光放在了内存条上⾯  

接下来，就要在内存条中划出⼀⽚专⻔的区域，⽤来临时存储数据。既然是专⽤的，那就需要有个名字。叫做栈。<font color='red'>栈其实只是⼀个乳名，实际上这个区域叫做堆栈</font>。要注意，内存⾥⾯还有个区域，叫做堆。和栈的特性很不⼀样。所以，栈的本质就是内存中的⼀个区域。他的特殊之处就在于，CPU从中存取数据的⽅式。就好像弹夹装⼦弹，就是<font color='red'>先⼊后出，后⼊先出</font>。  

⽽CPU中，很多对于数据的操作都要遵循这个规律。<font color='red'>在内存中，有⼀个个的存储单元，在存
储单元中，就有⼀⽚区域，就是堆栈。  </font>

![image-20230209202522706](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209202522706.png)

对于堆栈⽽⾔，<font color='red'>如果栈顶和栈底重合，那么表示栈⾥⾯没有数据</font>。如果需要往栈⾥⾯存放数据，那么栈顶指针就往上挪⼀挪，然后<font color='red'>将要存储的数据存放在栈顶的位置。这个动作就叫做压栈\⼊栈</font>。当需要从栈中取出数据的时候，就先<font color='red'>将数据保存到寄存器当中，然后栈顶往下挪，这个动作就叫做弹栈\出栈。</font>但是要注意，出栈了以后，<font color='red'>数据还是在堆栈中，只是这个数据就被当成了垃圾。  </font>

再进⼀步理解，就是我们的程序。要知道，我们的程序是以机器码的形式躺平在内存当中，每⼀句机器码都有⾃⼰的位置，也就是地址。 CPU执⾏程序的过程，就是把每⼀句机器码拿出来挨个分析，然后做相应操作。⽐如<font color='red'>函数调⽤的地址存取，就⽤到了堆栈。</font>  

### 1.2数据结构中的栈 

数据结构中的栈，我们就将其称之为栈结构的⼀个抽象数据类型。也就是<font color='red'>模仿了栈结构的特点，⽽做出的⼀系列动作  </font>

对于计算机⽽⾔，有两种存储结构。就是顺序存储结构、链式存储结构。同样的，我们可以⽤这两种结构来实现栈的操作。  

![image-20230209202724357](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209202724357.png)

![image-20230209202729563](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209202729563.png)

## 2 队列(缓存)

队列是⼀种特殊的线性表，特殊之处就在于<font color='red'>它只允许在表的前端进⾏删除操作，在表的后端进⾏插⼊操作</font>。和栈⼀样，队列也是⼀种操作受到限制的线性表。<font color='red'>进⾏插⼊操作的端称之为队尾，进⾏删除操作的端称之为队头。</font>队列中没有队列的时候，称之为空队列。队列的数据元素，⼜叫做队列元
素。<font color='red'>在队列中插⼊⼀个队列元素称之为⼊队，在队列中删除⼀个队列元素，称之为出队</font>。因为队列<font color='red'>只允许在⼀端插⼊，在另⼀端删除，所以只有最早进⼊的队列元素才可以从队列中删除，故队列⼜称为先进先出线性表。</font>  

### 2.1队列的应⽤

- 解决主机与外部设备速度不匹配(类似于打印机)
- 多⽤户引起的资源竞争问题

### 2.2单向队列  

#### 2.2.1顺序队列  

当我⽤⼀⽚<font color='red'>连续的存储空间来存储队列中的数据元素</font>的时候，这样的队列就称之为顺序队列。类似于顺序栈。⽤⼀维数组来存放顺序队列中的数据元素。队头设置在最近⼀个离开队列元素所占的位置。队尾设置在最近⼀个进⾏⼊队列的元素位置。那么队头和队尾随着插⼊和删除的变化⽽变化。<font color='red'>当队列为空时， front = rear；队列中的元素个数可以由队头 - 队尾求得。  </font>

![image-20230209203009192](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209203009192.png)

但是，这个时候，会有⼀个问题。当我们的队尾指针指向size - 1 时，代表⻓度已满。但是根据队列的规则，就实际情况来说，他还有空闲的空间。那么这个时候，我们就将其称之为<font color='red'>假溢出</font>。  

为了解决假溢出的问题，就是将我们的顺序队列看成是⾸位相接的循环结构。<font color='red'>⾸尾指示器不
变，这种队列就叫做，循环顺序队列  </font>

也就是说，当我们的队尾元素达到数组的上限时，如果还有数据元素⼊队并且数组的第0个空间是空闲时，队尾指示器就指向数组的0端，所以。<font color='red'>整个队尾指示器+1的操作就可以修改为：` rear =（rear + 1） %maxSize`；队头指示器同样是如此。</font>当队头的操作达到数组的上限的时候，如果还有数组元素出队，这个时候，队头指示器就要指向数组的0端。所以，<font color='red'>队头指示器+1的操作就是 `front =（front + 1） %maxSize`。  </font>

这样的话，就⼜有⼀个问题，队满和队空的时候，都有rear = front。为了解决这个问题，⼀
般的⽅法就是，少使⽤⼀个空间。所以，<font color='red'>我们判断队空的条件就变成了 rear = front。判断队满的条件是`（rear + 1） %maxSize = front`。与此同时，循环队列中数据元素的个数是`（rear - front + maxSize） %maxSize`</font>。  

```C
#include<stdio.h>
#include<stdlib.h>
typedef struct Queue {
	int* queue;//队列数组
	int rear;//队尾指针
	int front;//队头指针
	int maxSize;//最大长度
}queue;

queue* initQueue()
{
	queue* list = (queue*)malloc(sizeof(queue));
	list->queue = (int*)malloc(sizeof(int) * 5);
	list->rear = list->front = 0;
	list->maxSize = 5;
	return list;
}

/*

插入队列
int key 待插入的元素

queue* list 需要插入哪个队列
*/
void insert_queue(int key,queue* list)
{
	if ((list->rear + 1 )%list->maxSize != list->front)
	{
		list->queue[list->rear] = key;
		list->rear = ((list->rear) + 1) % list->maxSize;
	}
	else
	{
		//满了
	}
}

void delete_queue(queue* list)
{
	if (list->front != list->rear)
	{
		list->front = ((list->front) + 1) % list->maxSize;
	}
	else {
		//队空 不能删
	}
}

//进行输出
void printf_queue(queue* list)
{
	//先拿到队头和队尾指针
	int temp_front = list->front;
	int temp_rear = list->rear;

	for (int i = temp_front; i != temp_rear ; i = (i + 1) % list->maxSize)
	{
		printf("%d ", list->queue[i]);
	}
}
```



#### 2.2.2链队列 



### 2.3双端队列  

![image-20230209203309601](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209203309601.png)

对于双端队列来说，就是<font color='red'>两端都是结尾的队列</font>。队列的每⼀端都可以插⼊数据项和移除数据项。相对于普通队列。双端队列的⼊队和出队操作在两端都可以进进⾏,更加方便和实用

这种数据结构的特性，使得他更加的实⽤和⽅便。<font color='red'>当你只允许使⽤⼀端出队、⼊队操作的时候，他等价于⼀个栈。当限制⼀端只能出队，另⼀端只能⼊队，他就等价于⼀个普通队列。但是不能随便进出,都是有规定的方向的. </font>

<font color='red'>链表实现思路</font>:创建一个中间节点,使用两个指针 

右插动左值针 左插右指针(排队,左边进入排右边 右边进入排左边)

左插左删(右指针形成栈) 左插右删(左值针形成队列)

右插右删(左值针形成栈) 右插左删(右值针形成队列)

```C
#include<stdio.h>
#include<stdlib.h>

typedef struct LinkQueue {
	int element;//数据
	struct LinkQueue* pre;//前指针
	struct LinkQueue* next;//后指针
}Node;

void InitQueue();
void left_push(int key);
void left_pop();
void right_push(int key);
void right_pop();

Node* middle;//中间节点
Node* left;//左值针
Node* right;//右指针

int main()
{
	InitQueue();
	right_push(1);
	right_push(2);
	right_push(3);
	Node* temp = middle->pre;
	while (temp != NULL)
	{ 
		printf("%d ", temp->element);
		temp = temp->pre;
	}
	printf("\n");
	left_pop();
	temp = middle->pre;
	while (temp != NULL)
	{
		printf("%d ", temp->element);
		temp = temp->pre; 
	}
}

void InitQueue()
{
	middle = (Node*)malloc(sizeof(Node));//声明中间节点
	middle->next = NULL;
	middle->pre = NULL;
	left = middle;//左右指针指向中间
	right = middle;
}

//左插动右指针
void left_push(int key)
{
	Node* new_node = (Node*)malloc(sizeof(Node));//声明新节点
	new_node->element = key;
	right->next = new_node;
	new_node->pre = right;
	new_node->next = NULL;
	right = right->next;
}
//左删
void left_pop()
{
	//如果右指针指向中间节点 代表右插左删形成队列 就是普通的链表删除
	//如果没有指向中间节点 代表左插左删形成栈 将最后一个节点删除
	if (right == middle)
	{
        //先判断数据是否为空
        if(left == middle){
            //数据为空
            return;
        }
		Node* temp = right->pre;
		right->pre = right->pre->pre;
		right->pre->next = right;
		free(temp);
	}
	else 
	{
		Node* temp = right;
		right = right->pre;
		right->next = NULL;
		free(temp);
	}

}
//右插
void right_push(int key)
{
	Node* new_node = (Node*)malloc(sizeof(Node));
	new_node->element = key;
	left->pre = new_node;
	new_node->next = left;
	new_node->pre = NULL;
	left = left->pre;

}

void right_pop()
{
	//看左指针 如果左指针移动了 代表在进行右插右删
	//如果左指针没有动 在进行左插右删
	
	if (left == middle)
	{
        //先判断数据是否为空
        if(right == middle){
            //数据为空
            return;
        }
		Node* temp = left->next;
		left->next = left->next->next;
		left->next->pre = left;
		free(temp);
	}
	else
	{
		Node* temp = left;
		left = left->next;
		left->pre = NULL;
		free(temp);
	}
}
```

<font color='red'>数组实现思路</font>:创建一个数组,使用两个指针,只在初始化时进行指针初始化 

左插动左指针-- 右插动右指针++

左删动左指针++ 右删动右指针--

```C
#include<stdio.h>
#include<stdlib.h>
#define Size 5;
int *queue;//队列顺序表
int left,right;//定义左右指针
int maxSize,size;//定义最大元素个数和当前元素个数

void InitQueue(){
    size = 0;
    maxsize = Size;
    queue = (int *)malloc(sizeof(int) *maxsize);
}
//判断元素是否满了
int isFull(){
    if(size == maxSize){
        //满了
        return 1;
    }
    return 0;
}

//判断是否为空
int isEmpty(){
    return size==0;
}

//进行左插
void insert_left(int key){
    if(isFull())
    {
        //满了插入失败
    }
    else
    {
        if(isEmpty()){
            //空的时候定位指针
            left = right=0;
            queue[left] = key;
        }
        else{
            if(left == 0)
            {
                left = maxSize;
            }
            queue[--left] = key;
        }
        size++;
    }
}

//进行左删
void delete_left(){
    if(isEmpty()){
        //不空才能删除
    }
    else{
        if(left == maxSize-1){
            printf("被删除的元素为", queue[left]);
            left = 0;//maxSize-1+1归为0
            size--;
        }
        else{
            printf("被删除的元素为", queue[left]);
            left++;
            size--;
        }
    }
}

//进行右插
void insert_right(int key){
    if(isFull())
    {
        //满了插入失败
    }
    else
    {
        if(isEmpty()){
            //空的时候定位指针
            left = right=0;
            queue[right] = key;
        }
        else{
            if(right == maxSize - 1)
            {
                right = -1;//后面右++然后结果为0
            }
            queue[++right] = key;
        }
        size++;
    }
}

//进行左删
void delete_right(){
    if(isEmpty()){
        //不空才能删除
    }
    else{
        if(right == 0){
            printf("被删除的元素为", queue[right]);
            right = maxSize-1;//maxSize-1+1归为0
            size--;
        }
        else{
            printf("被删除的元素为", queue[right]);
            right--;
            size--;
        }
    }
}

//进行打印 左插和右插不同
void printf_left_queue(){
    //通过那个不动的指针进行遍历
    int tmp_front = right;
    int tmp_rear = left;
    int count = 0;
    while(count < size){
        if(tmp_front < 0){
            temp_front = maxSize - 1;
        }
        printf("%d ", queue[temp_front]);
        temp_front++;
        count++;
    }
}

//进行打印 左插和右插不同
void printf_right_queue(){
    //通过那个不动的指针进行遍历
    int tmp_front = left;
    int tmp_rear = right;
    int count = 0;
    while(count < size){
        if(tmp_front >maxSize-1){
            temp_front = 0;
        }
        printf("%d ", queue[temp_front]);
        temp_front--;
        count++;
    }
}
```



### 2.4 LRU（Least Recently Used）缓存淘汰  

![image-20230209203558226](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230209203558226.png)

1、新数据插⼊到链表头部
2、每当缓存命中（即缓存数据被访问），则将数据移到链表头部
3、当链表满的时候，将链表尾部的数据丢弃

这⾥我们是<font color='red'>根据时间来来判断</font>的，就是最近最久未使⽤的。如果<font color='red'>根据使⽤次数来判</font>断，做缓存的命中，那就叫做`LFU（Least Freequently used）`。⽬前Redis应该就是⽤的LFU。  

### 2.5延迟队列  

延迟队列相⽐于普通队列最⼤的区别就是在属性上⾯，普通的队列是先进先出，按⼊队顺序处理。<font color='red'>延时队列中的元素在⼊队时会制定⼀个延迟时间，表示其希望能够在经过该指定时间后处理</font>。从某种意义来说，他不像是⼀个队列。更像是⼀个<font color='red'>以时间为权重的堆。  </font>

使用场景:

- ⽤户可以在⼩程序中订阅不同的微信或者QQ 的模板消息，产品同学可以在⼩程序的管理端新建消息推送计划，当到达指定的时间节点的时候给所有订阅模板消息的⽤户进⾏消息推送。  

- 新建的订单，如果⽤户在 15 分钟内未⽀付，则⾃动取消。公司的会议预定系统，在会议预定成功后，会在会议开始前半⼩时通知所有预定该会议的⽤户。安全⼯单超过 24 ⼩时未处理，则⾃动拉企业微信群提醒相关责任⼈。⽤户下单外卖以后，距离超时时间还有 10 分钟时提醒外卖⼩哥即将超时。  处理的数据量⽐较⼤实时性要求⽐较⾼ 

### 2.6阻塞队列  

阻塞队列是这样的⼀种数据结构，它是⼀个队列（类似于⼀个List），可以存放0到N个元素。我们可以对这个队列执⾏插⼊或弹出元素操作，弹出元素操作就是获取队列中的第⼀个元素，并且将其从队列中移除；⽽插⼊操作就是将元素添加到队列的末尾。<font color='red'>当队列中没有元素时，对这个队列的弹
出操作将会被阻塞，直到有元素被插⼊时才会被唤醒；当队列已满时，对这个队列的插⼊操作就会被阻塞，直到有元素被弹出后才会被唤醒。</font>
在<font color='red'>线程池</font>中，往往就会⽤阻塞队列来保存那些暂时没有空闲线程可以直接执⾏的任务，等到线程空闲之后再从阻塞队列中弹出任务来执⾏。⼀旦队列为空，那么线程就会被阻塞，直到有新任务被插⼊为⽌。  

# 三 树

## 1.树的表达⽅式  

### 1.1树的概念  ![image-20230210172421147](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230210172421147.png)

图中可以看⻅⼀个使⽤树形结构存储的⼀个集合，这个集合就是{A， B， C.......}。对于数据A来说，和数据B、 C、 D有关系。对于数据B来说，和E， F， G有关系。这就是<font color='red'>⼀对多的关系</font>。  

我们将⼀对多的关系的集合中的数据元素按照图中的形式进⾏存储，整个存储形状在逻辑结果上⾯看，类似于实际⽣活中倒着的树，所以就将这种结构称之为树形结构。  

### 1.2树的结点  

结点：使⽤树结构存储的每⼀个数据元素都被称为“结点”。例如图中的A就是⼀个结点。  

根结点：有⼀个特殊的结点，这个<font color='red'>结点没有前驱</font>，我们将这种结点称之为根结点  

⽗结点（双亲结点）、⼦结点和兄弟结点：对于ABCD四个结点来说， A就是BCD的⽗结点，也称之为双亲结点。⽽BCD都是A的⼦结点，也称之为孩⼦结点。对于BCD来说，因为他们都有<font color='red'>同⼀个爹</font>，所以它们互相称之为兄弟结点。  

叶⼦结点：如果<font color='red'>⼀个结点没有任何⼦结点</font>，那么此结点就称之为叶⼦结点。

结点的度：<font color='red'>结点拥有的⼦树的个数</font>，就称之为结点的度。

树的度：<font color='red'>在各个结点当中，度的最⼤值</font>。为树的度。

树的深度或者⾼度：结点的层次<font color='red'>从根结点开始定义起，根为第⼀层</font>，根的孩⼦为第⼆层。依次类推。  

### 1.3树的存储结构  

#### 1.3.1双亲表示法  

##### 1.3.1.1顺序表表示形式  

![image-20230210172710287](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230210172710287.png)

![image-20230210172725994](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230210172725994.png)

每个数据放在数组中.

```C
#include<stdio.h>
#include<stdlib.h>
//当前结点对应的父亲是谁
//数据关系 1V1

typedef struct TreeNode {
	int data;//树中存放的数据
	int parent;//当前数据对应的父节点是谁 根节点的父节点-1

}Node;

Node* node[5];
int size;//当前元素个数

void Init(int key);
void insert_child(int key, int parent_node);
int find_parent(int parent);

int main()
{
	Init(5);
	insert_child(4, 5);
	insert_child(3, 4);
	printf("%d-------%d", node[2]->data, node[2]->parent);
}

void Init(int key)
{
	size = 0;
    node[size]->data = key;
    node[size]->parent = -1;
    size++;
}

/*
int key
	当前结点是谁 
int parent_node
	父节点是谁
*/
void insert_child(int key, int parent_node)
{
    //判断数组是否满了
	if (size == 5)
	{
		//满了
	}
	else
	{
		int parent_index = find_parent(parent_node);
        //先找父亲节点
		if (parent_index == -1)
		{
            //没找到父节点
			return;
		}
		else 
		{
            /*
			Node* new_node = (Node*)malloc(sizeof(Node));
			new_node->data = key;
			new_node->parent = parent_index;
			node[size] = new_node; 
			size++;
			*/
            node[size]->data = key;
			node[size]->parent = parent_index;
			size++;
		}
	}
}

int find_parent(int parent)
{
	for (int i = 0; i < size; i++)
	{
		if (node[i]->data == parent)
		{
			return i;
		}
	}
	return -1;
}
```

```C
//结点
/**
* @author Turing
* @version 1.0.0
* @Description TODO
**/
public class Node {
    //数据
    int data;
    //孩⼦指针域
    Node child;
    //兄弟指针域
    Node sibling;
    public Node(int data){
        this.data = data;
    }
}
//双亲表示法
/**
* @author Turing
* @version 1.0.0
* @Description TODO
**/
public class TreeParentDemo {
	Node node[];
	int size;//当前元素个数
	int maxSize;//当前最⼤元素个数
    public TreeParentDemo(int temp){
    	node = new Node[temp];
    	this.maxSize = temp;
    	this.size = 0;
    }
    /**
    * 构建跟结点
    * @param data 根节点的数据
    */
    public void insert(int data){
    //已有根节点 ⽆法继续构建根节点
    	if(size > 1){
    	//提示
    	}
    	Node node = new Node(data,-1);
    	this.node[size] = node;
    	size++;
    }
    /**
    * 插⼊⼦节点
    * @param data 待插⼊⼦节点的数据
    * @param index 该⼦节点插⼊到哪个结点下⾯优缺点说明
    由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这也就意味着，我们所
    有的结点都存有它双亲的位置。这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲
    结点，所⽤的时间复杂度为O(1)，直到parent为-1时，表示找到了树结点的根。可如果我们要知道结点
    的孩⼦是什么，对不起，请遍历整个结构才⾏。
    这真是麻烦，能不能改进⼀下呢?当然可以。我们增加⼀个结点最左边孩⼦的域，不妨叫它⻓
    ⼦域，这样就可以很容易得到结点的孩⼦。如果没有孩⼦的结点，这个⻓⼦域就设置为-1。
    */
    public void insertSon(int data,int index){
    //是否有这个⽗节点 如果没有该⽗节点 那就 提示⼀下
    	Node node = new Node(data,index);
    	this.node[size] = node;
    	size++;
    }
    
    public void show(){
    	for (int i = 0; i < size;i++){
    	System.out.println("数据： " + node[i].getData() + "⽗级结点为： " +
    	node[i].getParent());
    	}
    }
}
```

```C
//测试数据
/**
* @author Turing
* @version 1.0.0
* @Description TODO
**/
public class Test {
    public static void main(String[] args) {
        TreeParentDemo demo = new TreeParentDemo(10);
        demo.insert(1);
        demo.insertSon(2,0);
        demo.insertSon(3,0);
        demo.insertSon(4,0);
        demo.insertSon(7,1);
        demo.show();
    }
}
```

###### 1.3.1.1.1优缺点说明  

由于根结点是没有双亲的，所以我们<font color='red'>约定根结点的位置域设置为-1</font>，这也就意味着，我们所有的结点都存有它双亲的位置。这样的存储结构，我们可以根据结点的parent指针很容易找到它的双亲结点，所⽤的时间复杂度为O(1)，直到parent为-1时，表示找到了树结点的根。可如果我们要知道结点的孩⼦是什么，对不起，请遍历整个结构才⾏。  

这真是麻烦，能不能改进⼀下呢?当然可以。我们<font color='red'>增加⼀个结点最左边孩⼦的域</font>，不妨叫它⻓⼦域，这样就可以很容易得到结点的孩⼦。如果没有孩⼦的结点，这个⻓⼦域就设置为-1。  

对于有0个或1个孩⼦结点来说，这样的结构是解决了要找结点孩⼦的问题了。甚⾄是有2个孩⼦，知道了⻓⼦是谁，另⼀个当然就是次⼦了。另外⼀个问题场景，我们很关注各兄弟之间的关系，双亲表示法⽆法体现这样的关系，那我们怎么办?嗯，可以增加⼀个右兄弟域来体现兄弟关系，也就是说，每⼀个结点如果它存在右兄弟，则记录下右兄弟的下标。同样的，如果右兄弟不存在，则赋值为-1。  

#### 1.3.2孩⼦表示法  

![image-20230210213258515](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230210213258515.png)

![image-20230210213304303](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230210213304303.png)

父节点存在数组中，孩子作为链表接在后面

```C
#include<stdio.h>
#include<stdlib.h>
//孩子表示法 当前结点对应的孩子是谁
//一对多
typedef struct Child
{
	int data;//存放数据域
	struct Child* next;//指向下一个结点 指向孩子
}Node;


Node* node_array[20];
int size;//当前元素个数
void Init(int key);
void Great_Tree(int parent, int key);

int find_parent(int parent);

int main()
{
	Init(1);
	Great_Tree(1, 2);
	Great_Tree(1, 3);
	Great_Tree(1, 4);
	Great_Tree(2, 5);
	Great_Tree(2, 6);
	Great_Tree(3, 7);
    //进行输出
	for (int i = 0; i < size; i++)
	{
		printf("父节点为");
		printf("%d ", node_array[i]->data);
		Node* temp = node_array[i]->next;
		while (temp != NULL)
		{
			printf("孩子结点点为");
			printf("%d ", temp->data);
			temp = temp->next;
		}
		printf("\n");
	}
}


/*
初始化 给我根节点
int key 根节点的值
*/
void Init(int key)
{
	size = 0;
	node_array[size] = (Node*)malloc(sizeof(Node));
	node_array[size]->data = key;
	node_array[size]->next = NULL;
	size++;
}

/*
int parent
	父节点 

int key 
	当前结点对应的孩子
*/
void Great_Tree(int parent, int key)
{
	//找下标
	int index = find_parent(parent);
	if (index == -1)
	{

	}
	else
	{
		//把孩子作为新的结点加入到数组当中
		node_array[size] = (Node*)malloc(sizeof(Node));
		node_array[size]->data = key;
		node_array[size]->next = NULL;
		size++;
		//从数组链接到父节点
		Node* new_node = (Node*)malloc(sizeof(Node));
		new_node->data = key;
		new_node->next = node_array[index]->next;
		node_array[index]->next = new_node;
	}
}

int find_parent(int parent)
{
	for (int i = 0; i < size; i++)
	{
		if (node_array[i]->data == parent)
		{
			return i;
		}
	}
	return -1;
}


```

#### 1.3.3孩⼦兄弟表示法  

![image-20230210213322307](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230210213322307.png)

![image-20230210213326434](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230210213326434.png)

这种表示法，给查找某个结点的某个孩⼦带来了⽅便，只需要通过firstchild找到此结点的⻓⼦，然后再通过⻓⼦结点的rightsib找到它的⼆弟，接着⼀直下去，直到找到具体的孩⼦。当然，如果想找某个结点的双亲，这个表示法也是有做陷的，那怎么办呢?
对，如果真的有必要，<font color='red'>完全可以再增加⼀个parent指针域来解决快速查找双亲的问题</font>，这⾥就不再细谈了  

```C
#include<stdio.h>
#include<stdlib.h>
typedef struct ChildBro {
	struct ChildBro* child;//孩子指针
	struct ChildBro* sibling;//兄弟指针
	int key;//数据
}Node;
Node* root;//全局的根节点


//初始化根节点
void Init(int Key)
{
	root = (Node*)malloc(sizeof(Node));
	root->key = Key;
	root->child = NULL;
	root->sibling = NULL;
}

/*
int key
	当前结点
int parent
	当前结点的父亲
*/
void insert(int key, int parent)
{
	Node* tempNode = NULL;//先定位父节点是谁
	//查找父节点的位置
	if (tempNode == NULL)
	{
		//没找到
	}
	else 
	{
		if (tempNode->child == NULL)
		{
			Node* node = (Node*)malloc(sizeof(Node));
			node->key = key;
			node->child = NULL;
			node->sibling = NULL;
			tempNode->child = node;
		}
		else
		{
			tempNode = tempNode->child;
			Node* node = (Node*)malloc(sizeof(Node));
			node->key = key;
			node->child = NULL;
			node->sibling = NULL;
			node->sibling = tempNode->sibling;
			tempNode->sibling = node;
		}
	}
}
```

## 2.二叉树

### 2.1定义  

⼆叉树是每个结点最多有两个⼦树的树结构。也就是说⼆叉树不允许存在度⼤于2的树。它有五种最基本的形态：⼆叉树可以是空集。<font color='red'>根可以有空的左⼦树或者右⼦树；或者左右⼦树都是空。其中只有左⼦树或者右⼦树的叫做斜树。  </font>

![image-20230211195601862](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211195601862.png)

### 2.2⼆叉树的性质  

| 性 质    | 内容                                                         |
| -------- | ------------------------------------------------------------ |
| 性 质 ⼀ | 在⼆叉树的 i 层上⾄多有2^(i-1)个结点（i>=1）                 |
| 性 质 ⼆ | 深度为 k 的⼆叉树⾄多有 2^(k)-1 个结点（i>=1）               |
| 性 质 三 | 在⼀棵⼆叉树中，除了叶⼦结点（度为0）之外，就剩下度为2(n2)和1(n1)的结点了。则树的 结点总数为T = n0+n1+n2;在⼆叉树中结点总数为T，⽽连线数为T-1.所以有： n0+n1+n2-1 = 2*n2 +n1;最后得到<font color='red'>n0 = n2+1;</font> |
| 性 质 四 | 具有 n 个结点的<font color='red'>完全⼆叉树的深度为 [log2n] + 1 向下取整</font> |
| 性 质 五 | 如果有⼀棵有 n 个结点的完全⼆叉树(其深度为 [log2n] + 1，向下取整)的结点按层次序编号 (从第 1 层到第 [log2n] + 1，向下取整层，每层从左到右)，则对任⼀结点 i（1 <= i <= n）有 1.<font color='red'>如果 i = 1，则结点 i 是⼆叉树的根，⽆双亲</font>；<font color='red'>如果 i > 1，则其双亲是结点 [i / 2]，向下取 整 2.如果 2i > n 则结点 i ⽆左孩⼦，否则其左孩⼦是结点 2i 3.如果 2i + 1 > n 则结点⽆右孩⼦，否则其右孩⼦是结点 2i + 1</font> |

### 2.3满⼆叉树  

满⼆叉树要求<font color='red'>所有的分⽀结点都存在左右⼦树，并且所有的叶结点都在同⼀层上</font>，若<font color='red'>满⼆叉树的层数为 n，则结点数量为 2n-1 个结点，⼦叶只能出现在最后⼀层，内部结点的度都为 2</font>，如图所示。  

![image-20230211200014594](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211200014594.png)

### 2.4完全⼆叉树  

从定义上来说，完全⼆叉树是满⾜若<font color='red'>对⼀棵具有 n 个结点的⼆叉树按层序编号</font>，如果编号为 i的结点 (1 ≤ i ≤ n)于同样深度的满⼆叉树中编号为 i 的结点在⼆叉树的位置相同的⼆叉树。这样讲有些繁琐，可以理解为<font color='red'>完全⼆叉树⽣成结点的顺序必须严格按照从上到下，从左往右的顺序来⽣成结点</font>，如图所示  

![image-20230211200120065](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211200120065.png)

因此我们就不难观察出完全⼆叉树的特点，<font color='red'>完全⼆叉树的叶结点只能存在于最下两层，其中最下层的叶结点只集中在树结构的左侧，⽽倒数第⼆层的叶结点集中于树结构的右侧。当结点的度为 1时，该结点只能拥有左⼦树。  </font>

### 2.5⼆叉树的存储结构  

#### 2.5.1顺序存储  

由于⼆叉树的结点⾄多为2，因此这种性质使得⼆叉树是可以使⽤顺序存储结构来描述的。在使⽤顺序存储结构时我们需要令数组的下标体现结点之间的逻辑关系。我们先来看完全⼆叉树，如果我们按照从上到下，从左到右的顺序遍历完全⼆叉树时，顺序是这样的：  

![image-20230211200344018](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211200344018.png)

那么这个时候我们发现，如果设⽗结点的序号为k，<font color='red'>则⼦结点的序号⾮别为2k或者2k+1</font>，<font color='red'>⼦结点的序号和⽗结点都是相互对应的</font>。因此我们就可以⽤顺序存储结构来进⾏描述  

![image-20230211200409224](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211200409224.png)

⽤顺序存储结构描述如图示  

![image-20230211200451250](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211200451250.png)

那么对于⼀般的⼆叉树呢？我们<font color='red'>可以利⽤完全⼆叉树的编号来实现，在完全⼆叉树对应的结点是空结点。修改值为null。</font>  

![image-20230211200513893](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211200513893.png)

![image-20230211200519238](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211200519238.png)

如果是⼀个最特殊的⼆叉树，<font color='red'>对于⼀颗斜树，我们开辟的空间数远超过实际使⽤的空间，这样空间就被浪费了。因此顺序存储结构可⾏，但是不合适。  </font>

#### 2.5.2链式存储  

由于⼆叉树的每个结点最多只能有两个⼦树，因此我们就不需要使⽤上述的3种表达法来做。可以直接设置⼀个结点具有两个指针域与⼀个数据域，那么这样就可以建好⼆叉树链表。  

![image-20230211200653437](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211200653437.png)

![image-20230211200658344](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211200658344.png)

### 2.6⼆叉树的遍历  

#### 2.6.1递归遍历  

我们⽤斐波那契如何实现递归？  

```C
/**
* 对于⼀个斐波那契
* f(n) = f(n - 2) + f(n - 1)(n >= 2) 其中f(0) = 0,f(1) = 1。
*/
public static void main(String[] args) {
    
}
public int Fibonacci(int n){
    if (n == 0){
    	return 0;
    }else if(n == 1){
    	return 1;
    }else{
    	return Fibonacci(n - 2) + Fibonacci(n - 1);
    }
}
```

我们以传⼊的参数是4来举例。  

![image-20230211202443175](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211202443175.png)

我们在模拟递归调⽤的过程当中，和⼆叉树⻓的简直⼀模⼀样。那么对于⼆叉树，我们能不能⽤递归来做⼀些⽂章呢？  

```C
public void Traverse(Tree tree){
    if (tree == null){
        return;
    }
    //System.out.println(tree.data);前序遍历
    Traverse(tree.left);
    //System.out.println(tree.data);中序遍历
    Traverse(tree.right);
    //System.out.println(tree.data);后序遍历
}
```

根据输出的位置不同，根据输出的数据顺序不同。就分成了不同的遍历⽅式。  

##### 2.6.1.1前序遍历  

先访问根结点，然后左⼦树，然后右⼦树。 <font color='red'>中左右  </font>

![image-20230211201001120](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211201001120.png)

##### 2.6.1.2中序遍历  

从根结点出发，先进⼊根结点的左⼦树中序遍历，然后访问根结点，最后访问右⼦树。<font color='red'>左中右  </font>

![image-20230211201038301](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211201038301.png)

##### 2.6.1.3后序遍历  

从左到右先叶⼦后结点的⽅式进⼊左右树遍历，最后访问根结点。 <font color='red'>左右中。</font>  

![image-20230211201103473](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211201103473.png)

需要注意的是，⽆论是什么样的遍历顺序，<font color='red'>访问结点都是从根结点开始访问，按照从上到下，从左到右的顺序向下挖掘，</font>分为 3 种顺序主要因为我们需要有⼀些⽅式来描述递归遍历的结果，让我们可以抽象⼆叉树的结构，因此我们就按照输出语句放的位置不同⽽决定是什么序遍历，所以我这边就将 3 种遍历顺序放在⼀起谈。  

##### 2.6.1.4层序遍历法  

![image-20230211201252960](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211201252960.png)

层序遍历法不仅直观，⽽且好理解，但是我们要思考，<font color='red'>处于同⼀层的结点存在于不同⼦树，按照刚才的递归遍历法我们⽆法和其他⼦树产⽣沟通</font>，那该怎么实现？仔细观察，层序遍历就好像从根结点开始，⼀层⼀层向下扩散搜索，这就跟我们队列实现迷宫算法⾮常类似，因为迷宫算法的不同路径也是⽆关联的，但是我们是⽤⼴度优先搜索的思想可以找到最短路径。  

```C
/**
* ⼆叉树的遍历
* 层次遍历
*/
public void levelOrder(Node root){
    Queue<Node> queue = new LinkedList<>();
    Node current = null;
    if (root != null){
    	//offer只会返回false 不会报异常
    	//跟结点⼊队
    	queue.offer(root);
    }
    //队列不为空 执⾏循环
    while(!queue.isEmpty()){
        //poll 返回null
        current = queue.poll();
        System.out.print(current.data + " ");
        //如果有左节点，就把左节点加⼊
        if (current.leftChild != null){
            queue.offer(current.leftChild);
        }
        //如果有左节点，就把左节点加⼊
        if (current.rightChild != null){
            queue.offer(current.rightChild);
        }
    }
}
```

### 2.7扩展⼆叉树  

例如要确定⼀个⼆叉树，我们肯定不能只是把结点说明⽩，还需要把每个结点是否有左右孩⼦说明⽩。例如如图所示树结构，我们可以向其中填充结点，<font color='red'>使其的所有结点填充完后均具有左右结点，为了表示该结点其实是不存在的，我们需要设置⼀个标志来表示</font>，例如是“#”，那么这种描述就是拓展⼆叉树如图所示。  ![image-20230211201829908](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211201829908.png)

### 2.8⼆叉排序树（⼆叉查找树、⼆叉搜索树）  

#### 2.8.1性质  

1、如果他的<font color='red'>左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值</font>。

2、若它的<font color='red'>右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值</font>。

3、它的<font color='red'>左、右树⼜分为⼆叉排序树</font>。  

很显然，⼆叉排序树的定义是⼀个递归形式的定义，所以对于⼆叉排序树的操作都是基于递归的形式。  

⼆叉排序树既然名字中带有排序⼆字，这就是它相对于普通⼆叉树的优势所在了。此时可能还不是很清楚。没关系，我们⼀步步建⽴⼀颗⼆叉树。  

#### 2.8.2构建⼆叉排序树  

![image-20230211202843618](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211202843618.png)

假设，初始状态下，我们有如下的⽆序序列：  

![image-20230211202854542](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211202854542.png)

第⼀步：插⼊8作为根结点  

![image-20230211202904780](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211202904780.png)

第⼆步：插⼊3，与8做⽐较，发现⽐8⼩，且根结点没有左孩⼦，则将3插⼊到8的左孩⼦。  

![image-20230211202917535](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211202917535.png)

第三步：插⼊10，⾸先与根结点⽐较，发现⽐8⼤，则要将10插⼊到根结点的右⼦树；根结点8的右⼦树为空，则将10作为8的右孩⼦。  

![image-20230211202932412](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211202932412.png)

第四步：插⼊1，⾸先和根结点做⽐较，⽐根结点⼩，则应该插⼊到根结点的左⼦树。在跟根结点的左孩⼦3⽐较，发现⽐3还⼩，则应该插⼊3的左孩⼦。  

![image-20230211203102645](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211203102645.png)

按照以上思路构建一棵数

![image-20230211203151193](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211203151193.png)

⼆叉排序树的思路出来了，这个时候⼜有⼀个问题。我们理解的⼆叉排序树的构造，可是它的优势在哪⾥呢？  

对⽐⽆序序列，<font color='red'>⼆叉树的中序遍历的结果就是从小到大的排序</font>。  

![image-20230211203208752](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211203208752.png)

#### 2.8.3⼆叉排序树的查找操作 (按照排序二叉树定义进行遍历)

当数组有序了，我们查找元素，直接上查找算法，是不是就极其⽅便了？  

但是，如果仅仅是为了让他成为⼀个有序数列，还要存到数组⾥。还要再去查找他，那这也太弱了。实际上，<font color='red'>我们是直接从⼆叉树上进⾏查找的。怎么做呢？⼆叉排序树的查找操作与⼆分查找⾮常相似</font>，我们⼀起试着查找值为13的结点。  

⾸先，访问根结点8。  

![image-20230211203334079](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211203334079.png)

第⼆步：<font color='red'>根据⼆叉排序树的左⼦树均⽐根结点⼩，右⼦树均本根结点⼤的性质</font>。如果13 > 8,因此值为13的结点可能在根结点8的右⼦树当中，我们查看根结点的右⼦结点10；  

![image-20230211203357055](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211203357055.png)

第三步：与第⼆步相似， 13>10，所以查看结点10的右孩⼦14  

第四步：根据⼆叉排序树的左⼦树均⽐根结点⼩，右⼦树均⽐根结点⼤的性质， 13 < 14,因此查看 14 的左孩⼦13，发现刚好和要查找的值相等。  

![image-20230211203446838](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211203446838.png)

```C
/**
* 查找结点是否存在
* @param root 从根结点开始遍历查找
* @param key 待查找的结点
* @return
*/
public Boolean search(Node root,int key){
    while (root != null){
        if (key == root.data){
        	return true;
        }else if(key < root.data){
        	root = root.left;
        }else{
        	root = root.right;
        }
    }
    return false;
}
```

#### 2.8.4⼆叉排序树的插⼊操作  

对于任意⼀个待插⼊的元素 x 都是插⼊在⼆叉排序树的叶⼦结点，问题的关键就是确定插⼊的位置，原理当然和上⾯的查找操作⼀样<font color='red'>，从根结点开始进⾏判断，直到到达叶⼦结点，则将待插⼊的元素作为⼀个叶⼦结点插⼊即可</font>，多说⽆益，直接开始操作。如果我们要在原有的树中插⼊9，该怎么做呢？  

第⼀步，访问根结点8。
第⼆步：根据⼆叉排序树的左⼦树均⽐根结点⼩，右⼦树均⽐根结点⼤的性质， 9 > 8 ，因此值为9的结点应该插⼊到根结点 8 的右⼦树当中，我们查看根结点的右⼦节点10。
第三步：根据⼆叉排序树的左⼦树均⽐根结点⼩，右⼦树均⽐根结点⼤的性质， 9 < 10 ，因此值为9的结点应该插⼊到结点 10 的左⼦树当中，访问结点10的左孩⼦，发现为空，则将 9 作为 10号结点的左孩⼦插⼊。  

![image-20230211203718444](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211203718444.png)

```C
public void insert(Node root,int key){
    //记录⼆叉树的前⼀个结点
    Node prev = null;
    while (root != null){
        prev = root;
        if (key < root.data){
            root = root.left;
        }else if(key > root.data){
            root = root.right;
        }else{
            return;
        }
    }
    if (root == null){
    	root = new Node(key);
    }else if(key < prev.data){
    	prev.left = new Node(key);
    } else{
    	prev.right = new Node(key);
    }
}
```

#### 2.8.5⼆叉树的删除操作  

删除操作与查找和插⼊的操作就不⼀样啦。我们要开始分情况处理。  

##### 2.8.5.1、被删除的结点是叶⼦结点  

直接从⼆叉排序树当中移除即可，也不会影响树的结构。  

![image-20230211203951671](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211203951671.png)

##### 2.8.5.2、被删除的结点D仅有⼀个孩⼦  

如果<font color='red'>只有左孩⼦，没有右孩⼦，那么只需要把要删除结点的左孩⼦链接到要删除结点的⽗亲节点，然后删除D结点就好了</font>；如果<font color='red'>只有右孩⼦，没有左孩⼦，那么只要将要删除结点D的右孩⼦重接到要删除结点D的⽗亲结点。</font>  

假设我们要删除值为 14 的结点，其只有⼀个左孩⼦结点 13 ，没有右孩⼦ 。  

第⼀步：保存要删除结点 14 的 左孩⼦ 结点 13 到临时变量 temp，并删除结点 14；

![image-20230211204052325](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211204052325.png)第⼆步：将删除结点 14 的⽗结点 10 的 右孩⼦ 设置为 temp，即结点 13。![image-20230211204058437](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211204058437.png)
我们再以删除结点 10 为例，再看⼀下没有左孩⼦，只有⼀个右孩⼦的情况。  

第⼀步：保存要删除结点 10 的 右孩⼦ 结点 14 到临时变量 temp，并删除结点 10；  ![image-20230211204122669](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211204122669.png)

第⼆步：将删除结点 10 的⽗结点 8 的 右孩⼦ 设置为 temp，即结点 14。  

![image-20230211204128872](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211204128872.png)

##### 2.8.5.3被删除的结点的左右孩⼦都在  

对于这种情况就复杂⼀些了，但是我相信只要各位同学耐⼼看下去，⼀定会有收获，这⼀次我们将图变得复杂⼀点⼉，给原来结点 10 增加了⼀个左孩⼦结点 9 。  

![image-20230211204202577](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211204202577.png)

对于上⾯的⼆叉排序树的中序遍历结果如下所示  

![image-20230211204217337](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211204217337.png)

现在我们先不考虑⼆叉排序上的删除操作，⽽仅在得到的中序遍历结果上进⾏删除操作。我们以删除中序遍历结果当中的顶点8为例进⾏说明。  

![image-20230211204230520](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211204230520.png)

当删除中序遍历结果中的 8 之后，哪⼀种⽅式不会改变中序遍历结果的有序性呢？  

那我们就要⽤7或者9来填充，都不会影响数据的有序性，如果对应到我们的⼆叉排序树上⾯呢？  

相当于我们<font color='red'>先删除根结点8，然后根结点的左⼦树当中最⼤的元素7来替换根结点8的位置，或者⽤根结点的右⼦树当中最⼩的9来替换根结点的位置</font>。那么我们对于删除⼀颗⼆叉排序树上⼀个包含左右⼦树的结点就是这么做的。  

我们下⾯就来看删除左右孩⼦都存在的结点是如何实现的，依旧以删除根结点 8 为例。⾸先我们⼀起看⽤根结点的左⼦树当中值最⼤的结点 7 来替换根结点的情况。第⼀步：获得待删除结点 8 的左⼦树当中值最⼤的结点 7 ，并保存在临时指针变量 temp 当中（这⼀步可以通过从删除结点的左孩⼦3 开始，<font color='red'>⼀个劲地访问右⼦结点，直到叶⼦结点为⽌获得</font>）  

![image-20230211204541753](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211204541753.png)

第⼆步：将删除结点 8 的值替换为 7  ![image-20230211204556130](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211204556130.png)

第三步：删除根结点左⼦树当中值最⼤的结点（这⼀步可能左⼦树中值最⼤的结点存在左⼦结点，⽽没有右⼦结点的情况，那么删除就退化成了第⼆种情况，递归调⽤即可）：  

![image-20230211204822376](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211204822376.png)

我们再来⼀起看⼀下使⽤删除结点的 右⼦树 当中值最⼩的结点替换删除结点的情况  

第⼀步：查找删除结点 8 的右⼦树当中值最⼩的结点，即 9 （<font color='red'>先访问删除结点的右⼦结点10，然后⼀直向左⾛，直到左⼦结点为空</font>，则得到右⼦树当中值最⼩的结点）。  

![image-20230211205133882](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211205133882.png)

第⼆步：将删除结点 8 的值替换为 9  

![image-20230211205217034](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211205217034.png)

第三步：删除根结点右⼦树当中值最⼩的结点。  

![image-20230211205229679](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20230211205229679.png)

```C
public boolean deleteNode(Node root,int key){
	if (root == null){
		return false;
	}else{
		if (key == root.data){
			return delete(root);
        }else if(key < root.data){
            return deleteNode(root.left,key);
        }else{
            return deleteNode(root.right,key);
        }
	}
}
/**
*
*/
public boolean delete(Node node){
	Node temp = null;
/**
* 如果右⼦树空，只需要重新连接他的结点
* 如果是叶⼦节点，在这⾥也把叶⼦节点删除
*/
    if (node.right == null){
    	temp = node;
    	node = node.left;
    }else if (node.left == null){
        temp = node;
        node = node.right;
    } else{//左右⼦树都不为空
        temp = node;
        Node s = node;
        /**找到左⼦树的最⼤值*/
        s = s.left;
        while(s.right != null){
            temp = s;
            s = s.right;
        }
    	node.data = s.data;
        if(temp != node){
        	temp.right = s.left;
        }
        else{
        	temp.left = s.left;
        }
    }
    return true;
}
```



##### 2.8.5.4时间复杂度分析  

<font color='red'>⼆叉排序树的插⼊和查找、删除操作的最坏时间复杂度为 O（h），其中 h 是⼆叉排序树的⾼度</font>。最极端的情况下，我们可能必须从根结点访问到最深的叶⼦结点，斜树的⾼度可能变成n，插⼊和删除操作的时间复杂度将可能变为O（n） 。下图就是两颗斜树（就相当于单链表）。<font color='red'>这也是⼆叉排序树在进⾏多次插⼊操作后可能发⽣的不平衡问题，也是⼆叉排序树的缺陷所在</font>，但这依旧不妨碍其作为⼀个伟⼤的数据结构。  